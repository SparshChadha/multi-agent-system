# Multi-Format Autonomous AI System

## Table of Contents
1. [Overview](#overview)
2. [Architecture & Flow](#architecture--flow)
3. [Prerequisites](#prerequisites)
4. [Installation](#installation)
5. [Configuration & Environment Variables](#configuration--environment-variables)
6. [Running the System](#running-the-system)
    - [Running Locally](#running-locally)
    - [In Docker (Optional)](#running-in-docker-optional)
7. [Sample Inputs & Expected Outputs](#sample-inputs--expected-outputs)
8. [Troubleshooting](#troubleshooting)
9. [Contributing](#contributing)

## Overview
This project implements a multi-format autonomous AI system using LangGraph and Google Gemini models. It's designed to receive raw text input, classify its format (Email, JSON, PDF) and business intent, route it to a specialized agent for processing, and then determine an appropriate action based on the agent's output. The system logs its operations, optionally using Redis for persistent memory.

## Architecture & Flow
The system is built as a directed acyclic graph (DAG) using LangGraph. The main components and flow are as follows:

1.  **Classifier**: Receives the raw input text. It uses a Gemini LLM to determine the `format` (Email, JSON, PDF) and the `intent` (e.g., RFQ, Complaint, Invoice, Regulation, Fraud Risk) of the input.
2.  **Router**: Takes the `format` from the Classifier and conditionally routes the input payload to the appropriate specialized agent (EmailAgent, JSONAgent, or PDFAgent).
3.  **Specialized Agents**:
    * **EmailAgent**: Processes email content. It extracts fields like sender, urgency, and issue summary, identifies tone, flags potential spam/phishing, and suggests a primary action (e.g., ESCALATE, ACKNOWLEDGE, ROUTINE).
    * **JSONAgent**: Parses and validates JSON payloads against a defined schema. It checks for schema validity, deprecated versions, and unknown event types, outputting a validation status and any errors or warnings.
    * **PDFAgent**: Processes text extracted from PDF documents. It determines if the PDF is an INVOICE or a POLICY document, extracts relevant fields (e.g., invoice details, policy terms), and sets flags (e.g., HIGH_VALUE_INVOICE, COMPLIANCE_RISK). The PDFAgent dynamically uses the current date for some evaluations (e.g., PAST_DUE_INVOICE).
4.  **ActionRouter**: Receives the output from the specialized agent. Based on the agent's name and its structured output, this component determines and logs a final business action to be taken (e.g., post to an alert system, forward to a team, log and close).

All significant steps and data points during an orchestration run are logged to the console and, if Redis is configured and available, to a Redis-based memory store for later inspection.

The visual representation of this architecture is:
![Graph Architecture](graph_architecture.png)
*(This diagram can be generated by running `architecture.py`)*

## Prerequisites
* Python (3.9 or higher recommended)
* pip (Python package installer)
* Redis (Optional, for persistent memory logging. If not running, the system will proceed without it but memory will not be saved across sessions)
* Graphviz (Optional, if you want to generate the architecture diagram using `architecture.py`)
* Access to Google Gemini API and a valid API key.

## Installation
1.  **Clone the repository (if applicable)**:
    ```bash
    # git clone <repository-url>
    # cd <repository-directory>
    ```

2.  **Create and activate a Python virtual environment**:
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate
    ```

3.  **Install dependencies**:
    Create a `requirements.txt` file with the following content:
    ```txt
    langgraph
    langchain-google-genai
    redis
    python-dotenv
    graphviz
    # ipython # Optional, for interactive display in architecture.py
    ```
    Then run:
    ```bash
    pip install -r requirements.txt
    ```
## Configuration & Environment Variables

1.  **Google API Key**:
    The system requires a Google API key for the Gemini models used by the agents.
    * Create a file named `.env` in the root project directory.
    * Add your API key to the `.env` file:
        ```env
        GEMINI_KEY="YOUR_GOOGLE_API_KEY_HERE"
        ```
    The agent files (`classifier_agent.py`, `email_agent.py`, etc.) load this key using `python-dotenv`.

2.  **Redis Configuration**:
    The `langGraphRun.py` script attempts to connect to a Redis instance by default at `localhost:6379`.
    * If your Redis server runs on a different host or port, or requires a password, modify the connection parameters in `langGraphRun.py`:
        ```python
        redis_client = redis.Redis(host='YOUR_REDIS_HOST', port=YOUR_REDIS_PORT, db=0, decode_responses=True #, password='YOUR_REDIS_PASSWORD'
        )
        ```
    * If Redis is not available, the script will print an error and continue without saving memory logs to Redis.

## Running the System

### Running Locally

1.  **Set up Environment Variables**: Ensure your `.env` file is correctly configured with your `GEMINI_KEY` as described above.
2.  **Start Redis (Optional)**: If you want to use Redis for memory logging, ensure your Redis server is running and accessible.
3.  **Run the Orchestration Script**:
    Execute the main script from the project's root directory:
    ```bash
    python langGraphRun.py
    ```
    This will run the predefined examples, and you will see logs printed to the console showing the flow of data through the graph, including classification, routing, agent processing, and final actions. If Redis is connected, memory logs will also be indicated.

4.  **Generate Architecture Diagram (Optional)**:
    To generate/update the `graph_architecture.png` file:
    ```bash
    python architecture.py
    ```
    This requires Graphviz to be installed on your system.

### Running in Docker (Optional)
*(Instructions for Docker setup would go here. This would typically involve creating a `Dockerfile` and potentially a `docker-compose.yml` file if Redis is also to be containerized.)*

Currently, Docker setup is not provided.

## Sample Inputs & Expected Outputs
The `langGraphRun.py` script includes a list of sample inputs in the `examples` variable within its `if __name__ == "__main__":` block. These examples cover various scenarios for emails, JSON, and PDF-like text.

When you run the script, the expected output for each example will be:
* Console logs indicating the start of an orchestration with a unique ID.
* The input data snippet being processed.
* Logs from each step in the graph:
    * `[MEMORY_REDIS]` or `[MEMORY_SKIP]` messages showing data being written (or attempted to be written) to memory.
    * Classification results (format and intent).
    * Routing decisions.
    * Outputs from the specialized agents (EmailAgent, JSONAgent, PDFAgent).
    * `[ACTION]` logs detailing the final triggered action based on the `action_router` logic.
* A message indicating the completion of the orchestration and the final state of the graph.
* If Redis is connected, a full log retrieved from Redis for the orchestration run will be printed.

For instance, for a phishing email:
* Classifier might output: `Email|Fraud Risk`
* Router directs to EmailAgent.
* EmailAgent might output JSON with `"spam_flag": "PHISHING_RISK"` and `"action": "ESCALATE"`.
* ActionRouter logs an action like: `POST /alerts/email_phishing with details...` (depending on the specific rules in `action_router`).

## Troubleshooting

* **`API key expired` Error**:
    * **Problem**: The Google API key (`GEMINI_KEY` in your `.env` file) is no longer valid.
    * **Solution**: Generate a new API key from the Google Cloud Console or Google AI Studio and update it in your `.env` file.

* **`Could not connect to Redis` Error**:
    * **Problem**: The script cannot connect to the Redis server at the configured address (`localhost:6379` by default).
    * **Solution**:
        * Ensure your Redis server is running.
        * Verify the host and port in `langGraphRun.py` match your Redis server configuration.
        * If Redis is not intended to be used, this error is informational, and the script will proceed without memory logging.

* **Python Environment Issues / Module Not Found**:
    * **Problem**: Python cannot find the installed packages.
    * **Solution**:
        * Ensure you have activated your virtual environment (`source venv/bin/activate`).
        * Verify all dependencies from `requirements.txt` are installed in the active environment.

* **Incorrect Agent Behavior or Output**:
    * **Problem**: Agents are not extracting information correctly or the `action_router` is not triggering the expected actions.
    * **Solution**:
        * Review the prompts in the respective agent files (`core_Agents/*.py`). Prompt engineering is key to LLM behavior.
        * Check the logic within the `action_router` function in `langGraphRun.py` to ensure it correctly handles the outputs from the agents.
        * Examine the detailed memory logs (if Redis is enabled) or console output for the intermediate data passed between nodes to pinpoint where the process deviates.

## Contributing
Contributions are welcome! Please follow these general guidelines:
1.  Fork the repository.
2.  Create a new branch for your feature or bug fix.
3.  Make your changes.
4.  Ensure your code follows the existing style and includes relevant tests (if applicable).
5.  Update documentation (like this README) if you make changes to the architecture, setup, or usage.
6.  Submit a pull request with a clear description of your changes.

